{"./":{"url":"./","title":"简介","keywords":"","body":"简介 风行，一场戏；逐浪，一梦空~ 说明：整理内容来自于源码、官方文档、书籍、网络等方面，如涉及不能引用或者需要标明出处的内容，请联系pslshuihuo@163.com。 : 是高中时代日记本的名字，取自于“君子坦荡荡”，时光荏苒，愿中依然少年。 梳理个人技术栈，以便知识查阅、技术体系结构补齐。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"java/jdk/":{"url":"java/jdk/","title":"JDK","keywords":"","body":"JDK linux环境配置JDK #编辑文件 vim /etc/profile #添加环境变量 export JAVA_HOME=/fw/java/jdk1.8.0_191 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib:$CLASSPATH export JAVA_PATH=${JAVA_HOME}/bin:${JRE_HOME}/bin export PATH=$PATH:${JAVA_PATH} #激活 source /etc/profile console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"java/jdk/concurrent.html":{"url":"java/jdk/concurrent.html","title":"concurrent","keywords":"","body":"第一部分 Aomic数据类型 这部分都被放在java.util.concurrent.atomic这个包里面，实现了原子化操作的数据类型，包括 Boolean, Integer, Long, 和Referrence这四种类型以及这四种类型的数组类型。 第二部分 锁 这部分都被放在java.util.concurrent.lock这个包里面，实现了并发操作中的几种类型的锁 第三部分 java集合框架中的一些数据结构的并发实现 这部分实现的数据结构主要有List, Queue和Map。 第四部分 多线程任务执行 这部分大体上涉及到三个概念， Callable 被执行的任务 Executor 执行任务 Future 异步提交任务的返回数据 第五部分 线程管理类 这部分主要是对线程集合的管理的实现，有CyclicBarrier, CountDownLatch,Exchanger等一些类. console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"java/jdk/threadlocal.html":{"url":"java/jdk/threadlocal.html","title":"threadlocal","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"java/jdk/stream.html":{"url":"java/jdk/stream.html","title":"stream","keywords":"","body":"Stream 创建流Stream Java8 中的 Collection 接口被扩展，提供两个获取流的方法 : default Stream stream() : 返回一个顺序流 default Stream parallelStream() : 返回一个并行流 由数组创建流 Java8 中的 Arrays 的静态方法 stream() 可以获取数组流 : static Stream stream(T[] array) : 返回一个流 重载形式，能够处理对应基本类型的数组IntStream/LongStream/DoubleStream : 由值创建流 可以使用静态方法 Stream.of(), 通过显示值创建一个流，它可以接收任意数量的参数：public static Stream of(T… values) : 返回一个流 由方法创建流 : 创建无限流 可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流 迭代 public static Stream iterate(final T seed, final UnaryOperator f) 生成 public static Stream generate(Supplier s) Stream的中间操作实操 多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理。而在终止操作时一次性全部处理，称为惰性求值。 筛选与切片系列 方法 描述 filter(Predicate) 接收 Lambda ， 从流中排除某些元素（true表示通过，false表示被过滤掉了） distinct() 筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素 limit(Long) 截断流，使其元素不超过给定数量 peek(Consumer) 生成一个包含原Stream的所有元素的新Stream，同时会提供一个消费函数（Consumer实例），新Stream每个元素被消费的时候都会执行给定的消费函数； S unordered() 属于BaseStream的一个方法。使用较少。unordered操作不会进行任何显式的打乱流的操作(后面会有例子)。它的工作是：消除流中必须保持的有序约束，因此允许之后的操作使用 不必考虑有序的优化。 skip(long) 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补 映射系列 方法 描述 map(Function f) 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素 mapToInt(ToIntFunction f) 同上，将其映射成一个Integer元素 mapToLong(ToLongFunction f) 同上，将其映射成一个Long元素 mapToDouble(ToDoubleFunction f) 同上,将其映射成一个Double元素 flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 排序 方法 描述 sorted() 产生一个新流，其中按自然顺序排序 sorted(Comparator) 产生一个新流，其中按比较器顺序排序 Stream的终止操作 终端操作会从流的流水线生成结果，其结果可以是任何不是流的值，例如 : List、 Integer，甚至是 void 注 : 流进行了终止操作后，不能再次使用 查找与匹配 方法 描述 allMatch(Predicate p) 检查是否匹配所有元素 anyMatch(Predicate p) 检查是否至少匹配一个元素 noneMatch(Predicate p) 检查是否没有匹配所有元素 findFirst() 返回第一个元素 findAny() 返回当前流中的任意元素 count() 返回流中元素总数 max(Comparator c) 返回流中最大值 min(Comparator c) 返回流中最小值 forEach(Consumer c) 内部迭代(使用 Collection 接口需要用户去做迭代，称为外部迭代。相反， Stream API 使用内部迭代) forEachOrdered(Consumer c) 基本同forEach toArray() toArray(IntFunction g) 这个使用起来和List的toArray差不多 除了使用forEachOrdered保证顺序外，Collectors.toList（）也可以保证顺序，二都最终都是通过ForEachOrderedTask类来实现的，具体可以参看ForEachOp.ForEachOrderedTask类中的代码。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"java/jdk/function.html":{"url":"java/jdk/function.html","title":"function","keywords":"","body":"函数式接口 （1） 只包含一个抽象方法的接口。 （2） 接口中唯一抽象方法的命名并不重要，因为函数式接口就是对某一行为进行抽象，主要目的就是支持Lambda表达式。 （3） 可以在任意函数式接口上使用 @FunctionalInterface 注解，这样做可以检测它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口 Function所有接口 所有函数式接口都在这个包：java.util.function Bi. Int. Long. Double. other Function BiFunction IntFunction LongFunction DoubleFunction DoubleToIntFunction、DoubleToLongFunction、IntToDoubleFunction、LongToDoubleFunction、LongToIntFunction、IntToLongFunction、ToIntBiFunction、ToIntFunction、ToLongBiFunction、ToLongFunction、ToDoubleBiFunction、ToDoubleFunction Predicate BiPredicate IntPredicate LongPredicate DoublePredicate Supplier IntSupplier LongSupplier DoubleSupplier BooleanSupplier Consumer BiConsumer IntConsumer LongConsumer DoubleConsumer ObjIntConsumer、ObjLongConsumer、ObjDoubleConsumer BinaryOperator IntBinaryOperator LongBinaryOperator DoubleBinaryOperator UnaryOperator IntUnaryOperator LongUnaryOperator DoubleUnaryOperator 接口详解 接口 Function 方法：R apply(T t) 介绍：传入两个对象，根据T返回R；Function所传递的其实是一种行为，在定义时没有进行实现，在使用的时候由用户进行实现。 默认方法： 1. default Function compose(Function before) 方法本身接收了一个函数式接口，同时又返回了一个函数式接口。before函数式接口优先执行。 2. default Function andThen(Function after) 方法本身接收了一个函数式接口，同时又返回了一个函数式接口。after函数式接口后执行。 3. static Function identity() BiFunction接口： 1. Bi→Bidirectional：两个，双向 2. T表示传递给函数的第一个参数类型，U表示传递给函数的第二个参数类型，R表示函数的结果类型 3. default BiFunction andThen(Function after) 该方法传入的参数是Function而不是BiFunction，是因为首先它将传进来的两个参数进行操作，得到一个结果，而after对该结果进行操作，只接收该结果，即一个参数，因此传入的参数为Function即可。 接口Predicate 方法： boolean test(T t) 介绍：传入一个对象，返回一个boolean；Predicate表示一个判断，针对给定的参数T，来进行计算，如果输入参数符合匹配的条件，返回ture，否则返回false。 默认方法： 1. default Predicate and(Predicate other) 当前的Predicate与另外的一个Predicate进行逻辑与，如果当前的Predicate返回的结果为false，那么后者将不会被计算。 2. default Predicate negate() 表示当前的Predicate逻辑的相反面。 3. default Predicate or(Predicate other) 表示当前的Predicate与另外一个Predicate的逻辑或的操作。 静态方法： 1. static Predicate isEqual(Object targetRef) 判断与targetRef是否相等 接口Supplier 方法：T get() 介绍： 返回一个对象；Supplier表示结果的供应者，其作用就是不接收任何参数，同时返回一个结果。 接口Consumer 方法：void accept(T t) 介绍：传入一个对象，没有返回值； consumer表示一个接受单个输入参数并且没有返回值的操作，Consumer接口期望执行带有副作用的操作（即：Consumer的操作可能会更改输入参数的内部状态）。 默认方法： 1. default Consumer andThen(Consumer after) 两个Consumer, 先执行当前的Consumer，再执行另外一个Consumer。 接口UnaryOperator 介绍：一元运算，继承自Function；传入参数类型与返回类型相同 静态方法： 1. static UnaryOperator identity() 接口BinaryOperator 介绍：二无运算，继承自 extends BiFunction；返回类型与传入两个参数类型相同 静态方法： 1. public static BinaryOperator minBy(Comparator comparator) 2. public static BinaryOperator maxBy(Comparator comparator) Bi系列 BiConsumer,BiFunction,BiPredicate:从一个参数值,扩展支持到两个参数； 基本类型系列 为了减小装箱拆箱而消耗的性能； Double/Int/Long 简称 DIL DILXXX：代表参数值泛型 ToDILXXX：代表返回值泛型 DILToDILXXX：To前面代表参数值泛型 ,To后边代表返回值泛型 ObjDILConsumer(特殊) :相当于BiConsumer, 代表的第二个参数类型的泛型 Lamdba表达式 Lamdba表达式可理解为简洁的匿名函数， 简单地说，它即没有声明的方法，也没有访问修饰符、返回值声明和名字。 它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使 Java 语言的表达能力得到了提升。 语法：(parameters) -> expression (parameters) ->{ statements; } Lambda是建立在函数式接口的基础上的 方法引用 简单地说，就是一个Lambda表达式。 方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。 计算时，方法引用会创建函数式接口的一个实例。 当Lambda表达式中只是执行一个方法调用时，不用Lambda表达式，直接通过方法引用的形式可读性更高一些。 方法引用的方式： 类型 示例 引用对象的实例方法 Oboject::instanceMethodName 引用类的静态方法 ClassName::staticMethodName 引用类的实例方法 ClassName::methodName / 第一个参数为调用方法，后面的参数作为实例方法的传参 / 引用构造函数 ClassName::new 数组引用 Type::new (new String[]::new) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"java/jdk/jdk8.html":{"url":"java/jdk/jdk8.html","title":"jdk8","keywords":"","body":"JDK 8 特性 lamdba表达式 内容来源： https://www.cnblogs.com/qdhxhz/p/9393724.html Lamdba表达式 Lamdba表达式是一种匿名函数，简单地说，它是没有声明的方法，也即没有访问修饰符、返回值声明和名字。它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使 Java 语言的表达能力得到了提升。 Lambda表达式的语法 ``` 基本语法： i. (parameters) -> expression ii. (parameters) -> {statements;} 简单例子： // 1. 不需要参数,返回值为 5() -> 5 // 2. 接收一个参数(数字类型),返回其2倍的值x -> 2 * x // 3. 接受2个参数(数字),并返回他们的差值(x, y) -> x – y // 4. 接收2个int型整数,返回他们的和(int x, int y) -> x + y // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)(String s) -> System.out.print(s) ``` 函数式接口 Lamdba表达式建立在函数式接口的基础上 （1） 只包含一个抽象方法的接口，称为函数式接口 （2） 可以通过Lamdba表达式来创建该接口的对象 （3） console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"java/tomcat/":{"url":"java/tomcat/","title":"Tomcat","keywords":"","body":"Tomcat 简介         Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应HTML页面的访问请求。实际上Tomcat 部分是Apache 服务器的扩展，但它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。         尽管Tomcat也可以作为独立的Java Web服务器，但在对静态资源(HTML、图像文件等)的处理速度，Web服务器管理等方面都不如Apache、IIS服务器等其他专业的HTTP服务器，因此在实际应用中，常常把Tomcat与其他的HTTP服务器集成使用。对于不支持Servlet/JSP的HTTP服务器，可以通过Tomcat服务器来运行Servlet/JSP组件。         当Tomcat与其他HTTP服务器集成时，Tomcat服务器的工作模式通常为进程外的Servlet容器，Tomcat服务器与其他HTTP服务器之间通过专门的插件来通信。 解压目录简介 Tomcat的目录结构如下： bin：可执行文件（如启动和关闭Tomcat，有Windows和Linux脚本） conf：存放各种配置文件 lib：依赖的所有的jar包 logs：日志文件 temp：临时文件 webapps：存放web应用（默认的两个web应用，admin和manager，用来管理Tomcat的web服务）。 work：工作目录（jsp经过编译后生成的servlet） 配置文件简介 server.xml——Tomcat中最重要的配置文件。定义了Tomcat的体系结构，包括连接器端口、连接数、集群、虚拟目录、访问日志等 web.xml——默认文件的设置 context.xml——全局context的配置文件，包括JNDI（Java Naming and Directory Interface,Java命名和目录接口）等信息的配置 tomcat-user.xml——Tomcat管理员身份配置文件，关键是设置管理员的账户和密码 logging.properties——Tomcat日志配置文件，可以修改默认Tomcat日志路径和名称 Tomcat工作原理         当客户请求某个资源时，Servlet 容器使用 ServletRequest 对象把客户的请求信息封装起 来，然后调用 Java Servlet API 中定义的 Servlet 的一些生命周期方法，完成 Servlet 的执行， 接着把 Servlet 执行的要返回给客户的结果封装到 ServletResponse 对象中，最后 Servlet 容 器把客户的请求发送给客户，完成为客户的一次服务过程。 Tomcat工作模式 （1）：独立的Servlet容器（默认） （2）：进程内的Servlet容器（基于JNI） （3）：进程外的Servlet容器（基于IPC） JNI:Java Native Interface，本地通信接口，通过这个接口，Java 程序可以和其他语言编写的本地程序进行通信。 IPC:Inter Process Communication,进程间通信 Tomcat既可以作为独立的容器，又可以和其他Web服务器集成（例如IIS，Apache）作为进程内、进程间Servlet容器 Servlet容器分为： 1.  Web服务器插件：在其他的WEB服务器内部地址空间打开一个JVM，Java容器在这个开辟的JVM上运行Servlet 2.  Java容器 Tomcat组织结构 顶层类元素，可包含多个 Service 顶层类元素，可包含一个 Engine 和多个 Connector，本身并不能处理客户请求 连接器元素，代表通信接口，本身并不能处理客户请求 容器元素，为 Service 处理客户请求，可包含多个 Host 容器元素，为 Host 处理客户请求，可包含多个 Context 容器元素，为 Web 应用处理客户请求 Connector 组件表示一个接口，通过这个接口接收客户的请求，然后发送给其他的容器组件，最后再把服务器的响应结果传递给客户。 容器类元素： 上面介绍的 3 个组件：server,service,connector本身并不能处理客户请求，也不能生成响应。在 Tomcat 中只有 3 个组件是可以处理客户请求并生成响应的，这 3 个组件分别是 Engine、Host 和 Context。这 3 个组件分别代表了不同的服务范围，通过嵌套关系可以知道 3 个组件的范围有如下的关 系:Engine>Host>Context。 Engine 组件下可以包含多个 Host 组件，它为特定的 Service 组件处理所有客户请求。 一个 Host 组件代表一个虚拟主机，一个虚拟主机中可以包含多个 Web 应用(Context 组件)。 Context 组件代表一个 Web 应用。 WEB服务器种类： Java Web 服务器软件按照规模从小到大依次有:JSWDK、JServ、Resin、Tomcat、JRun、JBoss、WebLogic、WebSphere 等，其中 JSWDK、JServ、Resin、Tomcat、JRun、JBoss 是完全免费的软件。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"other/git.html":{"url":"other/git.html","title":"Git","keywords":"","body":"git操作： 在本地新建一个分支： git branch [newBranch] 切换到你的新分支: git checkout [newBranch] 创建并切换到新分支： git checkout -b [newBranch] 将新分支发布在github上： git push origin newBranch 在本地删除一个分支： git branch -d newBranch git co -b feature/fwpsl git push origin feature/fwpsl 在github远程端删除一个分支： git push origin :newBranch (分支名前的冒号代表删除) git checkout -- 指令从先从缓存区中拉取版本还原，如果没有 再到版本库中拉取还原。 git branch --set-upstream-to=origin/feature/ 分支跟踪 git config --add core.filemode false git log --pretty=oneline：将只会显示提交的commit id号和对应的注释 回退： ​ git reset --hard commit_id 或则是 git reset --hard HEAD^ 回退版本 ​ # hard选项，表示彻底将工作区、暂存区和版本库记录恢复到指定的版本库 ​ 使用“git push -f”提交更改 反做： ​ 使用“git revert -n 版本号”命令 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"other/gitbook.html":{"url":"other/gitbook.html","title":"GitBook","keywords":"","body":"GitBook console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"other/markdown.html":{"url":"other/markdown.html","title":"Markdown","keywords":"","body":"Markdown 语法 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"other/expression.html":{"url":"other/expression.html","title":"正则表达式","keywords":"","body":"正则表达式 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}